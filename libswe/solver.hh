/* vim: set sw=4 sts=4 et nofoldenable : */

/*
 * Copyright (c) 2007 Markus Geveler <apryde@gmx.de>
 *
 * This file is part of the SWE C++ library. LibSWE is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * LibSWE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */


#ifndef LIBSWE_GUARD_SOLVER_HH
#define LIBSWE_GUARD_SOLVER_HH 1

/**
 * \file
 *
 * DECLARATION of a Relaxation - based, Finite Volume MUSCL in space,
 * implicit/explicit Runge Kutta in time solver. Under heavy construction.
 *
 * Solver is arbitrary in precision.
 *
 * \ingroup grplibswe
 **/
 
#include <libla/dense_matrix.hh>
#include <libla/dense_vector.hh>
#include <libla/sparse_vector.hh>
#include <libla/banded_matrix.hh>

namespace pg512 {

    typedef unsigned long ulint;
    typedef unsigned int uint;
    typedef unsigned short usint;

    template<typename ResPrec_,
             typename PredictionPrec1_,
             typename PredictionPrec2_,
             typename InitPrec1_,
             typename InitPrec2_>
    class RelaxSolver
    {
        ///Private members.
        private:
            ///Stepsize in x direction.
            uint _delta_x;
            ///Stepsize in y direction.
            uint _delta_y;
            ///Size of timestep.
            ulint _delta_t;
            ///Current timestep.
            ulint _solve_time;
            
            ///The input- and to-be-updated - data.
            DenseMatrix<ResPrec_> * _bottom;
            DenseMatrix<ResPrec_> * _heigth;
            DenseMatrix<ResPrec_> * _x_veloc;
            DenseMatrix<ResPrec_> * _y_veloc;

            /**
              * Performs the preprocessing.
              * For Implementation see preprocessing.cc .
              **/
            void _do_preprocessing();

            ///The relaxation parameter: 0<eps<<1.
            double _eps;

            ///The number of cells in the finite volume descretization grid.
            ulint _n;
            
            ///Dimension sizes for rectangular grids.
            ulint _width;
            ulint _heigth;

            ///Vector _c is the relaxation - Matrix C`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _c;

            ///Vector _d is the relaxation - Matrix D`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _d;

            ///The corresponding "squares" of the above vectors, values generated by constructor.
            DenseVector<ResPrec_> _c_squared;
            DenseVector<ResPrec_> _d_squared;

            /** Vector under pointer contains boundary - scalars => must be (2a+2b) - dim.,
              * if a is the number of cell-steps in x-direction an b represents the same
              * in y- direction (For sqzare - grids it is 4n - dim, if n=squarroot(N), and N the total number of cells)
              * This might be useful for very complicated simulation settings. In simpler cases, one should use the
              * below options.
              **/
            DenseVector<ResPrec_> * _bottom_bound;
            DenseVector<ResPrec_> * _heigth_bound;
            DenseVector<ResPrec_> * _xveloc_bound;
            DenseVector<ResPrec_> * _yveloc_bound;

            /**
              * Boundaries: Scalars for rectangular grids. Simple version of the above vector-
              * based solution.
              *
              **/
            ResPrec_ _north_bound;
            ResPrec_ _south_bound;
            ResPrec_ _west_bound;
            ResPrec_ _east_bound;

            ///Flags for boundary usage.
            bool _simple_bound;
            bool _usage_reflect;
            bool _usage_constant;
            bool _usage_cyclic;
            bool _usage_transmissive;
        
            ///Vectors under pointers are the relaxation vectors. size is 3N, where N is the total number of grid cells.
            ///If using boundary-mapping, the size is 3N + 4(w + h + 4).
            DenseVector<ResPrec_> * _u;
            DenseVector<ResPrec_> * _v;
            DenseVector<ResPrec_> * _w;

            ///Vectors under pointers are the temp. relaxation vectors for the prediction stages.
            ///It`s size is 3N, where N is the total number of grid cells. If using boundary - mapping, the size is
            /// 3N + 4(w + h + 4).
            DenseVector<ResPrec_> * _u_temp;
            DenseVector<ResPrec_> * _v_temp;
            DenseVector<ResPrec_> * _w_temp;
            
            ///Vectors for the bottom slopes.
            DenseVector<ResPrec_> * _bottom_slopes_x; //size:w
            DenseVector<ResPrec_> * _bottom_slopes_y; //size:h

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_1, M_3.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _assemble_matrix1();

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_2, M_4.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _assemble_matrix2();


            /** Simplified matrix assembling.
              * Computes M_5.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix1();

            /** Simplified matrix assembling.
              * Computes M_6.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix2();

            /** Simplified matrix assembling.
              * Computes M_7.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix3();

            /** Simplified matrix assembling.
              * Computes M_8.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix4();

            /** Flow computation.
              * Used by preprocessing.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flow_x(uint i, uint j);

            /** Flow computation.
              * Used by preprocessing.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flow_y(uint i, uint j);

            /** Flow computation.
              *
              **/
            template<typename WorkPrec_>
            void _flow_x();

            /** Flow computation.
              * 
              **/
            template<typename WorkPrec_>
            void _flow_y();


            /** Source Term computation.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _source(uint i, uint j);
        
            /** Encapsulates the linear combination for prediction. Uses source() 
              * as well as the matrix assembling procedures to create the banded matrices.
              * Is used by solve().
              *
              **/
            template<typename WorkPrec_>
            void _do_prediction();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow  - computations.
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage1();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow - computations.
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage2();

             /** Encapsulates computation in one timestep. In the driver-application, one
               * can simply write a loop in which _do_solve is called at first and then the
               * renderable matrices are read out.
               *
               **/
             void _do_solve()
             {
                _do_setup_stage1<InitPrec1_>();
                _do_prediction<PredictionPrec1_>();
                _do_setup_stage2<InitPrec2_>();
                _do_prediction<PredictionPrec2_>();
                _do_correction<ResPrec_>();
                ++_solve_time;
             }

             /** Encapsulates the correction stage.
              *  Precision is that of the result.
              **/
             template<typename WorkPrec_> 
             void _do_correction();

        public:
            /**
              * Returns the current renderable heigth matrix
              * 
              **/
            DenseMatrix<ResPrec_> &getHeigth();

            /**
              * Returns the renderable bottom.
              *
              **/
            DenseMatrix<ResPrec_> &getBottom();
    };

}
#endif
