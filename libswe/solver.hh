/* vim: set sw=4 sts=4 et nofoldenable : */

/*
 * Copyright (c) 2007 Markus Geveler <apryde@gmx.de>
 * This file is part of the SWE C++ library. LibSWE is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * LibSWE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */


#ifndef LIBSWE_GUARD_SOLVER_HH
#define LIBSWE_GUARD_SOLVER_HH 1

/**
 * \file
 *
 * DECLARATION of a Relaxation - based, Finite Volume MUSCL in space,
 * implicit/explicit Runge Kutta in time solver. Under heavy construction.
 *
 * Solver is arbitrary in precision.
 *
 * \ingroup grplibswe
 **/
 
#include <libla/dense_matrix.hh>
#include <libla/dense_vector.hh>
#include <libla/sparse_vector.hh>
#include <libla/sparse_matrix.hh>
#include <libla/banded_matrix.hh>

namespace pg512 {

    typedef unsigned long ulint;
    typedef unsigned int uint;
    typedef unsigned short usint;

    template<typename ResPrec_,
             typename PredictionPrec1_,
             typename PredictionPrec2_,
             typename InitPrec1_,
             typename InitPrec2_>
    class RelaxSolver
    {
        ///Private members.
        private:
            ///Stepsize in x direction.
            uint _delta_x;
            ///Stepsize in y direction.
            uint _delta_y;
            ///Size of timestep.
            ulint _delta_t;
            ///Current timestep.
            ulint _solve_time;
            
            ///The input- and to-be-updated - data.
            DenseMatrix<ResPrec_> * _bottom;
            DenseMatrix<ResPrec_> * _heigth;
            DenseMatrix<ResPrec_> * _x_veloc;
            DenseMatrix<ResPrec_> * _y_veloc;

            /**
              * Performs the preprocessing.
              * For Implementation see preprocessing.cc .
              **/
            virtual void _do_preprocessing();

            /**
              * Updates the scalarfields in each timestep. 
              * 
              * \param time The current timestep.
              * 
              **/       
            virtual void _solve(ulint time);

            ///The relaxation parameter: 0<eps<<1.
            double _eps;

            ///The number of cells in the finite volume descretization grid.
            ulint _n;
            
            ///Dimension sizes for rectangular grids.
            ulint _width;
            ulint _heigth;

            ///Vector _c is the relaxation - Matrix C`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _c;

            ///Vector _d is the relaxation - Matrix D`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _d;

            ///The corresponding "squares" of the above vectors, values generated by constructor.
            DenseVector<ResPrec_> _c_squared;
            DenseVector<ResPrec_> _d_squared;

            /** Vector under pointer contains boundary - scalars => must be (2a+2b) - dim.,
              * if a is the number of cell-steps in x-direction an b represents the same
              * in y- direction (For sqzare - grids it is 4n - dim, if n=squarroot(N), and N the total number of cells)
              * This might be useful for very complicated simulation settings. In simpler cases, one should use the
              * below options.
              **/
            DenseVector<ResPrec_> * _bottom_bound;
            DenseVector<ResPrec_> * _heigth_bound;
            DenseVector<ResPrec_> * _xveloc_bound;
            DenseVector<ResPrec_> * _yveloc_bound;

            /**
              * Boundaries: Scalars for rectangular grids. Simple version of the above vector-
              * based solution.
              *
              **/
            ResPrec_ _north_bound;
            ResPrec_ _south_bound;
            ResPrec_ _west_bound;
            ResPrec_ _east_bound;

            ///Flags for boundary usage.
            bool _simple_bound = true;
            ///If set to false, absorbtion is used.
            bool _usage_reflect = true;
        
            ///Vectors under pointers are the relaxation vectors. size is 3N, where N is the total number of grid cells.
            DenseVector<ResPrec> * _u;
            DenseVector<ResPrec> * _v;
            DenseVector<ResPrec> * _w;

            ///Vectors under pointers are the temp. relaxation vectors for the prediction stages.
            ///It`s size is 3N, where N is the total number of grid cells.
            DenseVector<ResPrec> * _u_temp;
            DenseVector<ResPrec> * _v_temp;
            DenseVector<ResPrec> * _w_temp;

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_1, M_2, M_5, M_6 (or M_8, ...)due to the set number.
              * For implementation see libswe/assemble.cc.
              *
              * \param number Number is elementOf({1,2,5,6}) or elementOf({8,9,...}).
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _assemble_matrix(usint number);

            /** Simplified matrix assembling. See above.
              * For implementation see matrix_assemble.cc.
              *
              *  \param number Number is elementOf({3,4,7,8}) or elementOf({10,11,...}). 
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix(usint number);

            /** Flow computation.
              * For implementation see flow.cc .
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flowX(uint i, uint j);

            /** Flow computation.
              * For implementation see libswe/flow.cc .
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flowY(uint i, uint j);


            /** Source Term computation.
              * For implementation see libswe/source.cc .
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _source(uint i, uint j);
        
            /** Encapsulates the linear combination for prediction. Uses source() 
              * as well as the matrix assembling procedures to create the banded matrices.
              * Is used by solve().
              * For implementation see libswe/prediction.cc.
              *
              **/
            template<typename WorkPrec_>
            void _do_prediction();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow().
              * For Implementation see libswe/setup.cc .
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage1();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow().
              * For Implementation see libswe/setup.cc .
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage2();

             /** Encapsulates computation in one timestep.
              *
              **/
             void _solve()
             {
                _do_setup_stage1<PredictionPrec1_>();
                _do_prediction<PredictionPrec1_>();
                _do_setup_stage2<PredictionPrec2_>();
                _do_prediction<PredictionPrec2_>();
             }

        public:
            /**
              * Encapsulates the simulation stage.
              *
              * \param maxtime The number of timesteps to be processed.
              **/
            void doSimulation(uint  maxtime)
            {
                _do_preprocessing();
                for(ulint i = 0 ; i < maxtime ; ++i)
                {
                    _solve_time =i;
                    _solve();
                }
            }

    };
}
#endif
