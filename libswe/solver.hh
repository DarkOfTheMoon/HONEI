/* vim: set sw=4 sts=4 et nofoldenable : */

/*
 * Copyright (c) 2007 Markus Geveler <apryde@gmx.de>
 * This file is part of the SWE C++ library. LibSWE is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * LibSWE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */


#ifndef LIBSWE_GUARD_SOLVER_HH
#define LIBSWE_GUARD_SOLVER_HH 1

/**
 * \file
 *
 * Implementation of 2DSWE_Solver, a base class for 
 * 2D Shallow Water equations - solvers
 *
 * and DECLARATION of a Relaxation - based, Finite Volume MUSCL in space,
 * implicit/explicit Runge Kutta in time solver.
 *
 * Both are arbitrary in precision.
 *
 * \ingroup grpswe
 **/
 
#include <libla/dense_matrix.hh>
#include <libla/dense_vector.hh>
#include <libla/sparse_vector.hh>
#include <libla/sparse_matrix.hh>

namespace pg512 {

    typedef unsigned long ulint;
    typedef unsigned int uint;
    typedef unsigned short usint;

    template<typename ResPrec_>
    class 2DSWESolver
    {
        ///Private members.
        private:
            ///Stepsize in x direction.
            uint _delta_x;
            ///Stepsize in y direction.
            uint _delta_y;
            ///Size of timestep.
            ulint _delta_t;
            ///Current timestep.
            ulint _solve_time;
            
            ///The input- and to-be-updated - data.
            DenseMatrix<ResPrec_> * _bottom;
            DenseMatrix<ResPrec_> * _heigth;
            DenseMatrix<ResPrec_> * _x_veloc;
            DenseMatrix<ResPrec_> * _y_veloc;

            /**
              * Performs the preprocessing.
              * For Implementation see preprocessing.cc .
              **/
            virtual void _do_preprocessing();

            /**
              * Updates the scalarfields in each timestep. 
              * 
              * \param time The current timestep.
              * 
              **/       
            virtual void _solve(ulint time);

        public:
            /**
              * Encapsulates the simulation stage.
              *
              * \param maxtime The number of timesteps to be processed.
              **/
            void _do_simulation(uint  maxtime)
            {
                _do_preprocessing();
                for(ulint i = 0 ; i < maxtime ; ++i)
                {
                    _solve_time =i;
                    _solve(i);
                }
            }

    };

    template< typename ResPrec_,
              typename PredictionPrec1_,
              typename PredictionPrec2_,
              typename InitPrec1_,
              typename InitPrec2_,
              typename InputPrec_>
    class 2DSWERelaxImExRKFVMUSCLSolver : public 2DSWESolver<ResPrec_>
    {
        ///Private members:
        private:
            ///The relaxation parameter: 0<eps<<1.
            double _eps;

            ///The number of cells in the finite volume descretization grid.
            ulint _n;

            ///Vector _c is the relaxation - Matrix C`s diagonal-vector (must be 3-dim.).
            DenseVector<InputPrec_> * _c;

            ///Vector _d is the relaxation - Matrix D`s diagonal-vector (must be 3-dim.).
            DenseVector<InputPrec_> * _d;

            ///The corresponding "squares" of the above vectors, values generated by constructor.
            DenseVector<InputPrec_> _c_squared;
            DenseVector<InputPrec_> _d_squared;

            /** Vector under pointer contains boundary - scalars => must be (2a+2b) - dim.,
              * if a is the number of cell-steps in x-direction an b represents the same
              * in y- direction (For sqzare - grids it is 4n - dim, if n=squarroot(N), and N the total number of cells)
              * This might be useful for very complicated simulation settings. In simpler cases, one should use the
              * below options.
              **/
            DenseVector<InputPrec_> * _bottom_bound;
            DenseVector<InputPrec_> * _heigth_bound;
            DenseVector<InputPrec_> * _xveloc_bound;
            DenseVector<InputPrec_> * _yveloc_bound;

            /**
              * Boundaries: Scalars for rectangular grids. Simple version of the above vector-
              * based solution.
              *
              **/
            InputPrec_ _north_bound;
            InputPrec_ _south_bound;
            InputPrec_ _west_bound;
            InputPrec_ _east_bound;

            ///Flag for boundary usage.
            bool _simple_bound = true;
        
            ///Vectors under pointers are the relaxation vectors. size is 3N, where N is the total number of grid cells.
            DenseVector<ResPrec> * _u;
            DenseVector<ResPrec> * _v;
            DenseVector<ResPrec> * _w;

            ///Vectors under pointers are the temp. relaxation vectors for the prediction stages.
            ///It`s size is 3N, where N is the total number of grid cells.
            DenseVector<ResPrec> * _u_temp;
            DenseVector<ResPrec> * _v_temp;
            DenseVector<ResPrec> * _w_temp;
         
            /** Theta value computation. The most elementary operation within the solver.  
              * It accesses various elements within relaxation - vectors and uses libla/ScalarProduct.
              * For Implementation see libswe/theta.cc.
              *
              * \param x Flag for dimension.
              * \param plus Flag for direction.
              * \param i Access parameter 1.
              * \param j Access parameter 2.
              *
              **/
            template<typename WorkPrec_>
            WorkPrec_ _theta(bool x, bool plus, uint i, uint j);

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_1, M_2, M_5, M_6 (or M_8, ...)due to the set number.
              * For implementation see matrix_assemble.cc.
              *
              * \param number Number is elementOf({1,2,5,6}) or elementOf({8,9,...}).
              *
              **/
            template<typename WorkPrec_>
            void _assemble_matrix(usint number);

            /** Simplified matrix assembling. See above.
              * For implementation see matrix_assemble.cc.
              *
              *  \param number Number is elementOf({3,4,7,8}) or elementOf({10,11,...}). 
              *
              **/
            template<typename WorkPrec_>
            void _quick_assembleMatrix(usint number);

            /** Flow computation.
              * For implementation see flow.cc .
              *
              * \param x Flag for dimension.
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flow(bool x, uint i, uint j);

            /** Source Term computation.
              * For implementation see source.cc .
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            DenseVector<WorkPrec_> _source(uint i, uint j);
        
            /** Encapsulates the linear combination for prediction. Uses source() 
              * as well as the matrix assembling procedures to create the banded matrices.
              * Is used by solve().
              * For implementation see prediction.cc.
              *
              **/
            template<typename WorkPrec_>
            void _do_prediction();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow().
              * For Implementation see setup.cc .
              *
              *\param stage1 Flag for the prediction stage.
              *
              **/
            template<typename WorkPrec_>
            void _do_setup(bool stage1);

            /** Note: For the implementation of derived memberfunctions see:
              * 
              * solve() : simulation.cc,
              * doPreprocessing() : preprocessing.cc.
              *
              * 
              **/
            template<typename WorkPrec_>
            void _solve(ulint time);

            template<typename WorkPrec_>
            void _do_preprocessing(ulint time);


    };


}
#endif
