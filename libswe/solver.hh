/* vim: set sw=4 sts=4 et nofoldenable : */

/*
 * Copyright (c) 2007 Markus Geveler <apryde@gmx.de>
 * This file is part of the LA C++ library. LibSWE is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * LibSWE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */


#ifndef LIBSWE_GUARD_SOLVER_HH
#define LIBSWE_GUARD_SOLVER_HH 1

/**
 * \file
 *
 * Implementation of 2DSWE_Solver, a base class for 
 * 2D Shallow Water equations - solvers
 *
 * and DECLARATION of a Relaxation - based, Finite Volume MUSCL in space,
 * implicit/explicit Runge Kutta in time solver.
 *
 * Both are arbitrary in precision.
 *
 * \ingroup grpswe
 **/
 
#include <libla/dense_matrix.hh>
#include <libla/dense_vector.hh>
#include <libla/sparse_vector.hh>
#include <libla/sparse_matrix.hh>

namespace pg512 {

    typedef unsigned long ulint;
    typedef unsigned int uint;
    typedef unsigned short usint;

    template<typename ResPrec_>
    class 2DSWE_Solver
    {
        
        ///private members
        ///stepsize in x direction
        uint deltax;
        ///stepsize in y direction
        uint deltay;
        ///size of timestep
        ulint deltat;
        ///current timestep
        ulint solvetime;

        ///SWE Solvers do not allocate memory,they  only know, where the data resides
        DenseMatrix<ResPrec_> * bottom;
        DenseMatrix<ResPrec_> * heigth;
        DenseMatrix<ResPrec_> * xveloc;
        DenseMatrix<ResPrec_> * yveloc;

        /**
          * Does whatever necessary for preprocessing.
          * For Implementation see preprocessing.hh .
         **/
        virtual void doPreprocessing();

        /**
         * Updates the scalarfields in each timestep. 
         * 
         * \param time The current timestep.
         * 
         **/       
        virtual void solve(ulint time);

        public:
        /**
         * Encapsulates the simulationstage.
         *
         * \param maxtime The number of timesteps to be processed
         **/
        void doSimulation(uint  maxtime)
        {
            doPreprocessing();
            for(ulint i = 0; i < maxtime; ++i)
            {
                solvetime =i;
                solve(i);
            }
        }

    };

    template< typename ResPrec_,
              typename PredictionPrec1_,
              typename PredictionPrec2_,
              typename InitPrec1_,
              typename InitPrec2_,
              typename InputPrec_>
    class 2DSWE_Relax_ImExRK_FVMUSCL_Solver : public 2DSWE_Solver<ResPrec_>
    {
        ///private members:
        ///the relaxation parameter: 0<eps<<1
        double eps;

        ///The number of cells in the finite volume descretization grid.
        ulint n;

        ///vector under pointer contains the relaxation - Matrix C`s diagonal-vector (must be 3-dim.)
        DenseVector<InputPrec_> * c;

        ///vector under pointer contains the relaxation - Matrix D`s diagonal-vector (must be 3-dim.)
        DenseVector<InputPrec_> * d;

        ///the corresponding "squares" of the above vectors, values generated by constructor
        DenseVector<InputPrec_> csquared;
        DenseVector<InputPrec_> dsquared;

        /** vector under pointer contains boundary - scalars => must be (2a+2b) - dim.,
          * if a is the number of cell-steps in x-direction an b represents the same
          * in y- direction (For sqzare - grids it is 4n - dim, if n=squarroot(N), and N the total number of cells)
          * This might be useful for very complicated simulation settings. In simpler cases, one should use the
          * below options.
          **/
        DenseVector<InputPrec_> * bottombound;
        DenseVector<InputPrec_> * heigthbound;
        DenseVector<InputPrec_> * xvelocbound;
        DenseVector<InputPrec_> * yvelocbound;

        /**
          * boundaries: scalars for rectangular grids. Simple version of the above vector-
          * based solution.
          *
          **/
        InputPrec_ northbound;
        InputPrec_ southbound;
        InputPrec_ westbound;
        InputPrec_ eastbound;

        ///Flag for boundary usage.
        bool simplebound = true;
        
        ///Vectors under pointers are the relaxation vectors. size is 3N, where N is the total number of grid cells.
        DenseVector<ResPrec> * u;
        DenseVector<ResPrec> * v;
        DenseVector<ResPrec> * w;

        ///Vectors under pointers are the temp. relaxation vectors for the prediction stages.
        ///size is 3N, where N is the total number of grid cells.
        DenseVector<ResPrec> * utemp;
        DenseVector<ResPrec> * vtemp;
        DenseVector<ResPrec> * wtemp;
         
         /** Theta value computation. The most elementary operation within the solver.  
           * It accesses various elements within relaxation - vectors and uses libla/ScalarProduct.
           * For Implementation see libswe/theta.cc
           *
           * \param x Flag for dimension.
           * \param plus Flag for direction.
           * \param i Access parameter 1
           * \param j Access parameter 2
           *
           **/
        template<typename WorkPrec_>
        WorkPrec_ theta(bool x, bool plus, uint i, uint j);

         /** Basic matrix assembling. Uses Limiters and theta().
           * Computes M_1, M_2, M_5, M_6 (or M_8, ...)due to the set number.
           * For implementation see matrix_assemble.cc
           *
           * \param number Number is elementOf({1,2,5,6}) or elementOf({8,9,...})
           *
           **/
        template<typename WorkPrec_>
        void assembleMatrix(usint number);

        /** Simplified matrix assembling. See above.
          * For implementation see matrix_assemble.cc
          *
          *  \param number Number is elementOf({3,4,7,8}) or elementOf({10,11,...})
          *
          **/
        template<typename WorkPrec_>
        void quickAssembleMatrix(usint number);

        /** Flow computation.
          * For implementation see flows.cc .
          *
          * \param x Flag for dimension.
          * \param i Access Parameter 1.
          * \param j Access Parameter 2.
          * 
          **/
        template<typename WorkPrec_>
        DenseVector<WorkPrec_> flow(bool x, uint i, uint j);

        /** Source Term computation.
          * For implementation see source.cc .
          *
          * \param i Access Parameter 1.
          * \param j Access Parameter 2.
          * 
          **/
        DenseVector<WorkPrec_> source(uint i, uint j);


        
        /** Encapsulates the linear combination for prediction. Uses source() 
          * as well as the matrix assembling procedures to create the banded matrices.
          * Is used by solve().
          * For implementation see prediction.cc
          *
          **/
        template<typename WorkPrec_>
        void doPrediction();

        /** Encapsulates the setup for the values utemp, vtemp, wtemp.
          * Uses flow().
          * For Implementation see setup.cc .
          *
          *\param stage1 Flag for the prediction stage.
          *
          **/
        template<typename WorkPrec_>
        void doSetup(bool stage1);


        /** Note: For the implementation of derived memberfunctions see:
          * 
          * solve() : simulation.hh
          * doPreprocessing() : preprocessing.hh
          *
          * 
          **/
        template<typename WorkPrec_>
        void solve(ulint time);

        template<typename WorkPrec_>
        void doPreprocessing(ulint time);


    };


}
#endif
