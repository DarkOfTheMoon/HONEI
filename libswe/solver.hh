/* vim: set sw=4 sts=4 et nofoldenable : */

/*
 * Copyright (c) 2007 Markus Geveler <apryde@gmx.de>
 * Copyright (c) 2007 Volker Jung <volker.m.jung@t-online.de>
 *
 * This file is part of the SWE C++ library. LibSWE is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * LibSWE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */


#ifndef LIBSWE_GUARD_SOLVER_HH
#define LIBSWE_GUARD_SOLVER_HH 1

/**
 * \file
 *
 * DECLARATION of a Relaxation - based, Finite Volume MUSCL in space,
 * implicit/explicit Runge Kutta in time solver. Under heavy construction.
 *
 * Solver is arbitrary in precision.
 *
 * \ingroup grplibswe
 **/
 
#include <libla/dense_matrix.hh>
#include <libla/dense_vector.hh>
#include <libla/sparse_vector.hh>
#include <libla/banded_matrix.hh>
#include <math.h>

namespace pg512 {

    typedef unsigned long ulint;
    typedef unsigned int uint;
    typedef unsigned short usint;

    template<typename ResPrec_,
             typename PredictionPrec1_,
             typename PredictionPrec2_,
             typename InitPrec1_,
             typename InitPrec2_>
    class RelaxSolver
    {
        ///Private members.
        private:
            ///Stepsize in x direction.
            ResPrec_ _delta_x;
            ///Stepsize in y direction.
            ResPrec_ _delta_y;
            ///Size of timestep.
            ResPrec_ _delta_t;
            ///Current timestep.
            ulint _solve_time;
            
            ///The input- and to-be-updated - data.
            DenseMatrix<ResPrec_> * _bottom;
            DenseMatrix<ResPrec_> * _height;
            DenseMatrix<ResPrec_> * _x_veloc;
            DenseMatrix<ResPrec_> * _y_veloc;

            ///The relaxation parameter: 0<eps<<1.
            double _eps;

	    ///The squared Manning-Coefficient used by the sourceterm computation.
	    double _manning_n_squared;

            ///The number of cells in the finite volume descretization grid.
            ulint _n;
            
            ///Dimension sizes for rectangular grids.
            ulint _d_width;
            ulint _d_height;

            ///Vector _c is the relaxation - Matrix C`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _c;

            ///Vector _d is the relaxation - Matrix D`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _d;

            ///The corresponding "squares" of the above vectors, values generated by constructor.
            DenseVector<ResPrec_> * _c_squared;
            DenseVector<ResPrec_> * _d_squared;

            /** Vectors contain the boundary - scalars => They have to be (2a+2b) - dimensional,
              * if a is the number of cell-steps in x-direction and b represents the same for
              * y- direction (For square - shaped grids it is 4n dimensional, where n = squareroot(N), and N is the total number of cells)
              * This might be useful for very complicated simulation settings. In simpler cases, one should use the
              * below options.
              **/
            DenseVector<ResPrec_> * _bottom_bound;
            DenseVector<ResPrec_> * _height_bound;
            DenseVector<ResPrec_> * _xveloc_bound;
            DenseVector<ResPrec_> * _yveloc_bound;

            /**
              * Boundaries: Scalars for rectangular grids. Simple version of the above vector-
              * based solution.
              *
              **/
            ResPrec_ _north_bound;
            ResPrec_ _south_bound;
            ResPrec_ _west_bound;
            ResPrec_ _east_bound;

            ///Flags for boundary usage.
            bool _simple_bound;
            bool _usage_reflect;
            bool _usage_constant;
            bool _usage_cyclic;
            bool _usage_transmissive;
        
            ///Vectors _u, _v, _w pointers are the relaxation vectors. size is 3N, where N is the total number of grid cells.
            ///If using boundary-mapping, the size is 3N + 4(w + h + 4).
            DenseVector<ResPrec_> * _u;
            DenseVector<ResPrec_> * _v;
            DenseVector<ResPrec_> * _w;

            ///Vectors under pointers are the temp. relaxation vectors for the prediction stages.
            ///It`s size is 3N, where N is the total number of grid cells. If using boundary - mapping, the size is
            /// 3N + 4(w + h + 4).
            DenseVector<ResPrec_> * _u_temp;
            DenseVector<ResPrec_> * _v_temp;
            DenseVector<ResPrec_> * _w_temp;
            
            ///Vectors for the bottom slopes.
            DenseVector<ResPrec_> * _bottom_slopes_x; //size:w
            DenseVector<ResPrec_> * _bottom_slopes_y; //size:h

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_1, M_3.
              *
              * \param m1 Matrix m1 is the first Matrix to be assembled.
              * \param m3 Matrix m3 is the second Matrix to be assembled.
              *
              **/
            template<typename WorkPrec_>
            void _assemble_matrix1(BandedMatrix<WorkPrec_>* m1, BandedMatrix<WorkPrec_>* m3);

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_2, M_4.
              *
              * \param m1 Matrix m2 is the first Matrix to be assembled.
              * \param m3 Matrix m4 is the second Matrix to be assembled.
              *
              **/
            template<typename WorkPrec_>
            void _assemble_matrix2(BandedMatrix<WorkPrec_>* m2, BandedMatrix<WorkPrec_>* m4);


            /** Simplified matrix assembling.
              * Computes M_5.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix1();

            /** Simplified matrix assembling.
              * Computes M_6.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix2();

            /** Simplified matrix assembling.
              * Computes M_7.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix3();

            /** Simplified matrix assembling.
              * Computes M_8.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix4();

            /** Flow computation.
              * Used by preprocessing.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flow_x(uint i, uint j);

            /** Flow computation.
              * Used by preprocessing.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flow_y(uint i, uint j);

            /** Flow computation.
              *
              **/
	    template<typename WorkPrec_>
            void _flow_x(DenseVector<WorkPrec_> & vector);

            /** Flow computation.
              * 
              **/
            template<typename WorkPrec_>
            void _flow_y(DenseVector<WorkPrec_> & vector);


            /** Source Term computation.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _source(uint i, uint j);
        
            /** Encapsulates the linear combination for prediction. Uses source() 
              * as well as the matrix assembling procedures to create the banded matrices.
              * Is used by solve().
              *
              **/
            template<typename WorkPrec_>
            void _do_prediction();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow  - computations.
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage1();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow - computations.
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage2();

             /** Encapsulates computation in one timestep. In the driver-application, one
               * can simply write a loop in which _do_solve is called at first and then the
               * renderable matrices are read out.
               *
               **/
             void _do_solve()
             {
                _do_setup_stage1<InitPrec1_>();
                _do_prediction<PredictionPrec1_>();
                _do_setup_stage2<InitPrec2_>();
                _do_prediction<PredictionPrec2_>();
                _do_correction<ResPrec_>();
                ++_solve_time;
             }

             /** Encapsulates the correction stage.
              *  Precision is that of the result.
              **/
             template<typename WorkPrec_> 
             void _do_correction();

        public:
            /**
              * Returns the current renderable heigth matrix
              * 
              **/
            DenseMatrix<ResPrec_> &getHeight();

            /**
              * Returns the renderable bottom.
              *
              **/
            DenseMatrix<ResPrec_> &getBottom();

            /**
              * Performs the preprocessing.
              **/
            void do_preprocessing();

            ///Constructors
            /**
             * First simple public constructor for tests.
             *
             * \param heigth The input heigth -field.
             * \param bottom The input bottom -field.
             * \param u1 The x -velocity field.
             * \param u2 The y -velocity field.
             * \param u The relaxation vector u.
             * \param v The relaxation vector v.
             * \param w The relaxation vector w.
             * \param dwidth The width of the FV - discretization grid.
             * \param dheigth The heigth of the FV - discretization grid.
             * \param deltax The x - stepsize.
             * \param deltay The y - stepsize.
             * \param deltat The time - stepsize.
             * \param eps The relaxation parameter.
             * \param bottomx The vector for the bottom slopes in x direction.
             * \param bottomy The vector for the bottom slopes in y direction.
             **/
            RelaxSolver(DenseMatrix<ResPrec_> *height,
                        DenseMatrix<ResPrec_> *bottom,
                        DenseMatrix<ResPrec_> *u1,
                        DenseMatrix<ResPrec_> *u2,
                        DenseVector<ResPrec_> *u,
                        DenseVector<ResPrec_> *v,
                        DenseVector<ResPrec_> *w,
                        ulint dwidth,
                        ulint dheight,
                        ResPrec_ deltax,
                        ResPrec_ deltay,
                        ResPrec_ deltat,
                        double eps,
                        DenseVector<ResPrec_> * bottomx,
                        DenseVector<ResPrec_> * bottomy)
            {
                this->_height = height;
                this->_bottom = bottom;
                this->_x_veloc = u1;
                this->_y_veloc = u2;
                this->_u = u;
                this->_v = v;
                this->_w = w;
                this->_d_width = dwidth;
                this->_d_height = dheight;
                this->_delta_x = deltax;
                this->_delta_y = deltay;
                this->_delta_t = deltat;
                this->_eps = eps;

                this->_simple_bound = true;
                this->_usage_reflect = true;
                this->_usage_constant = false;
                this->_usage_cyclic = false;
                this->_usage_transmissive = false;

                this->_n = _d_width * _d_height;

                this->_bottom_slopes_x = bottomx;
                this->_bottom_slopes_y = bottomy;
		this->_manning_n_squared = 0.000625;
            }

    };

    ///MEMBER FUNCTION TEMPLATE IMPLEMENTATION

    /**
     *
     * Implementation of the preprocessing stage of the RelaxSolver.
     *
     * At first, the input scalarfields have to be mapped onto a larger
     * DenseMatrix in order to apply boundary conditions.
     *
     * Secondly, the h,u1 und u2 - values have the
     * locations in the relaxation vectors.
     *
     * The preprocessing stage`s third task is to compute the bottom slopes.
     *
     **/
    template<typename ResPrec_, 
             typename PredictionPrec1_,
             typename PredictionPrec2_,
             typename InitPrec1_,
             typename InitPrec2_>
    void RelaxSolver<ResPrec_, PredictionPrec1_, PredictionPrec2_, InitPrec1_, InitPrec2_>::do_preprocessing()
    {
        /// Setting up initial conditions:
        /// v_0(x,y) = F(u_0(x,y)) using flowX(),
        /// w_0(x,y) = G(u_0(x,y)) using flowY().
        /// where u = transpose((h q1 q2)), v = transpose((v1 v2 v3)) and w = transpose((w1 w2 w3))
        /// and q1 = h*u1, q2 = h*u2.
        /// Then apply boundary conditions.
    
        ///Provide maps.
        DenseMatrix<ResPrec_> hbound((this->_d_width)+4,  (this->_d_height)+4, 0);
        DenseMatrix<ResPrec_> u1bound((this->_d_width)+4, (this->_d_height)+4, 0);
        DenseMatrix<ResPrec_> u2bound((this->_d_width)+4, (this->_d_height)+4, 0);
        DenseMatrix<ResPrec_> bbound((this->_d_width)+4,  (this->_d_height)+4, 0);


        ///Do the mapping by applying boundary - usage.
        if(this->_usage_reflect && this->_simple_bound)
        {
            ///If assuming, that all input fields are exactly of the same size, we can do all the work within
            ///one loop - pair:
            for (unsigned long i = 0; i!= hbound.rows(); ++i) 
            {
                DenseVector<ResPrec_> actual_row = hbound[i];
                for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                                     j_END(actual_row.end_elements());
                                                                     j!= j_END; ++j)
                {
                    ///Check if boundary - ghost cell is going to be accessed.
                    if(i<2 || i>=(hbound.rows()-2) ||(j.index()<2 || j.index() >=(hbound.columns()-2)))
                    {
                        hbound[i][j.index()] = 0;
                        bbound[i][j.index()] = 100000; //TODO: PosInf
                        u1bound[i][j.index()] = 0;
                        u2bound[i][j.index()] = 0;
                    }
                    else
                    {
                        hbound[i][j.index()] = (*_height)[i-2][(j.index())-2];
                        bbound[i][j.index()] = (*_bottom)[i-2][(j.index())-2];
                        u1bound[i][j.index()] =(*_x_veloc)[i-2][(j.index())-2];
                        u2bound[i][j.index()] =(*_y_veloc)[i-2][(j.index())-2];
                    }
                }
            }
        }//TODO: the other cases of boundary usage

        ///Building up the relaxation - vectors by concatenating the maps` rows.
        ///We need to compute u first in order to be able to compute the initial flows. After this, by using
        ///forward iterators, the v and w vectors can be set up.
        for (ulint i= 0; i!= hbound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = hbound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k((*_u).begin_elements());
                                                                j!= j_END; ++j)
            {
                (*_u)[k.index()] = hbound[i][j.index()];
                (*_u)[(k.index())+1] = u1bound[i][j.index()] * hbound[i][j.index()];
                (*_u)[(k.index())+2] = u2bound[i][j.index()] * hbound[i][j.index()];
                ++k; ++k; ++k;
            }
    
        }

        for (ulint i = 0; i!= u1bound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = u1bound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k((*_v).begin_elements());
                                                                j!= j_END; ++j)
            {
                DenseVector<ResPrec_> flow =_flow_x<ResPrec_>(i,j.index());

                (*_v)[k.index()] = flow[0];
                (*_v)[(k.index())+1] = flow[1];
                (*_v)[(k.index())+2] = flow[2];
                ++k; ++k; ++k;
            }
        }
    
        for (ulint i = 0; i!= u2bound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = u2bound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k((*_w).begin_elements());
                                                                j!= j_END; ++j)
            {
                DenseVector<ResPrec_> flow = this->_flow_y<ResPrec_>(i,j.index());

                (*_w)[k.index()] = flow[0];
                (*_w)[(k.index())+1] = flow[1];
                (*_w)[(k.index())+2] = flow[2];
                ++k; ++k; ++k;
            }
        }
    
        ///Now, that the relaxation vectors have been provided, the only thing left to do is to 
        ///compute the bottom slopes.
        for (ulint i = 0; i!= bbound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = bbound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k((*_bottom_slopes_x).begin_elements()),
                                                            l((*_bottom_slopes_y).begin_elements());
                                                                j!= j_END; ++j)
            {
                if(i>0 && j.index()>0)
                {
                    (*_bottom_slopes_x)[k.index()] = (bbound[i][j.index()] - bbound[i-1][j.index()]) /this->_delta_x;  
                    (*_bottom_slopes_y)[l.index()] = (bbound[i][j.index()] - bbound[i][(j.index())-1]) /this->_delta_y;                
 
                }
                else
                {
                    (*_bottom_slopes_x)[k.index()] = -100000; 
                    (*_bottom_slopes_y)[l.index()] = -100000;               
 
                }
                ++k;
                ++l;
            }   
        }
    

    }   

///Implementation of flow-processing functions.

    /**
     *
     * Flow computation in x-direction.
     * \param vector The vector, for which the flow is going to be computed.
     **/

    template <typename ResPrec_,
	      typename PredictionPrec1_,
	      typename PredictionPrec2_,
	      typename InitPrec1_,
	      typename InitPrec2_>
    template <typename WorkPrec_>
    void RelaxSolver<ResPrec_, PredictionPrec1_, PredictionPrec2_, InitPrec1_, InitPrec2_>::_flow_x(DenseVector<WorkPrec_> & vector)
    {
	if (!(vector.size() % 3)) 
	{
	    typename DenseVector<WorkPrec_>::DenseElementIterator _resultvectoriterator(vector.begin_elements());
	    WorkPrec_ _resultcomponentone, _resultcomponenttwo, _resultcomponentthree;
	    for (typename DenseVector<WorkPrec_>::DenseElementIterator l(vector.begin_non_zero_elements()), l_end(vector.end_non_zero_elements()); l != l_end; ++l)
	    {	
	        // Compute additional gravitation-based term for flowcomponent two
	        WorkPrec_ _gravterm = WorkPrec_(9.81 * l * l / 2);

	        // Compute the influence of the waterdepth
	        _resultcomponenttwo = 1 / l;
	        _resultcomponentthree = 1 / l;
	        ++l;

	        // Compute the influence of the waterflow in X-direction
		_resultcomponentone = l;
	        _resultcomponenttwo = _resultcomponenttwo * l * l + _gravterm;
		_resultcomponentthree *= l;
	        ++l;

	        // Compute the influence of the waterflow in Y-direction and add the gravition-based term
	        _resultcomponentthree *= l ;

	        // Write the computed values into the resultvector
	        _resultvectoriterator = _resultcomponentone;
	        ++_resultvectoriterator;
	        _resultvectoriterator = _resultcomponenttwo;
	        ++_resultvectoriterator;
	        _resultvectoriterator = _resultcomponentthree;
	        ++_resultvectoriterator;
	    }
	}
	else
	{
	    std::cout << "Tststs... size of given vector does not match the requirements (size modulo 3 = 0).";
	}
    }


    /**
     *
     * Flow copmutation in y-direction.
     *
     * \param vector The vector, for which the flow is going to be computed.
     **/
  
    template <typename ResPrec_,
	      typename PredictionPrec1_,
	      typename PredictionPrec2_,
	      typename InitPrec1_,
	      typename InitPrec2_>
    template <typename WorkPrec_>
    void RelaxSolver<ResPrec_, PredictionPrec1_, PredictionPrec2_, InitPrec1_, InitPrec2_>::_flow_y(DenseVector<WorkPrec_> & vector)
    {
	if (!(vector.size() % 3)) 
	{
	    typename DenseVector<WorkPrec_>::DenseElementIterator _resultvectoriterator(vector.begin_elements());
	    WorkPrec_ _resultcomponentone, _resultcomponenttwo, _resultcomponentthree;
	    for (typename DenseVector<WorkPrec_>::DenseElementIterator l(vector.begin_non_zero_elements()), l_end(vector.end_non_zero_elements()); l != l_end; ++l)
	    {
	        // Initialize locale resultcomponent variables
	        _resultcomponentone = WorkPrec_(1);
	        _resultcomponenttwo = WorkPrec_(1);
	        _resultcomponentthree = WorkPrec_(1);
	
	        // Compute additional gravitation-based term for flowcomponent two
	        WorkPrec_ _gravterm = WorkPrec_(9.81 * l * l / 2);

	        // Compute the influence of the waterdepth
	        _resultcomponenttwo *= 1 / l;
	        _resultcomponentthree *= 1 / l;
	        ++l;

	        // Compute the influence of the waterflow in X-direction
	        _resultcomponenttwo *= l;
	        ++l;

	        // Compute the influence of the waterflow in Y-direction and add the gravition-based term
	        _resultcomponentone *= l;
	        _resultcomponenttwo *= l;
	        _resultcomponentthree = (_resultcomponentthree * l * l) + _gravterm;

	        // Write the computed values into the resultvector
	        _resultvectoriterator = _resultcomponentone;
	        ++_resultvectoriterator;
	        _resultvectoriterator = _resultcomponenttwo;
	        ++_resultvectoriterator;
	        _resultvectoriterator = _resultcomponentthree;
	        ++_resultvectoriterator;
	    }
	}
	else
	{
	    std::cout << "Tststs... size of given vector does not match the requirements (size modulo 3 = 0).";
	}
    }

    /**
     *
     * Flow computation in x-direction for a single cell.
     *
     * This function is used only by the preprocessing stage.
     *
     * \param i First coordinate of the processed cell.
     * \param j Second coordinate of the processed cell.
     *
     **/

    template <typename ResPrec_,
	      typename PredictionPrec1_,
	      typename PredictionPrec2_,
	      typename InitPrec1_,
	      typename InitPrec2_>	  
    template <typename WorkPrec_>
    DenseVector<WorkPrec_> RelaxSolver<ResPrec_, PredictionPrec1_, PredictionPrec2_, InitPrec1_, InitPrec2_>::_flow_x(uint i, uint j)
    {
	DenseVector<WorkPrec_> _result(ulint(3), ulint(0), ulint(1));
	WorkPrec_ _temp = (*_v)[(this->_d_width + 4) * i + j];

	// Compute term for gravitional influence
        WorkPrec_ _gravterm = 9.81 * _temp * _temp / 2;

	_result[1] = 1 / _temp;
        _result[2] = _result[1];

	_temp = (*_v)[(this->_d_width + 4) * i + j + 1];
        _result[0] = _temp;
        _result[1] *= _temp * _temp;
	_result[2] *= _temp;

        _temp = (*_v)[(this->_d_width + 4) * i + j + 2];
	_result[1] += _gravterm;
        _result[2] *= _temp;

	return _result;
    }

    /**
     *
     * Flow computation in y-direction for a single cell.
     *
     * This function is used only by the preprocessing stage
     *
     * \param i First coordinate of the processed cell.
     * \param j Second coordinate of the processed cell.
     *
     **/

    template <typename ResPrec_,
	      typename PredictionPrec1_,
	      typename PredictionPrec2_,
	      typename InitPrec1_,
	      typename InitPrec2_>	  
    template <typename WorkPrec_>
    DenseVector<WorkPrec_> RelaxSolver<ResPrec_, PredictionPrec1_, PredictionPrec2_, InitPrec1_, InitPrec2_>::_flow_y(uint i, uint j)
    {
        DenseVector<WorkPrec_> _result(ulint(3), ulint( 0), ulint( 1));
	WorkPrec_ _temp = (*_w)[(this->_d_width + 4) * i + j];

        // Compute term for gravitional influence
	WorkPrec_ _gravterm = 9.81 * _temp * _temp / 2;

        _result[1] = 1 / _temp;
	_result[2] = _result[1];

        _temp = (*_w)[(this->_d_width + 4) * i + j + 1];
	_result[1] *= _temp;

        _temp = (*_w)[(this->_d_width + 4) * i + j + 2];
	_result[0] *= _temp;
        _result[1] *= _temp;
        _result[2] = _result[2] * _temp * _temp + _gravterm;

	return _result;
    }


    /**
     *
     * Source term computation for a single cell (i, j).
     *
     * \param i First coordinate of the processed cell.
     * \param j Second coordinate of the processed cell.
     *
     **/

    template <typename ResPrec_,
	      typename PredictionPrec1_,
	      typename PredictionPrec2_,
	      typename InitPrec1_,
	      typename InitPrec2_>
    template <typename WorkPrec_>
    DenseVector<WorkPrec_> RelaxSolver<ResPrec_, PredictionPrec1_, PredictionPrec2_, InitPrec1_, InitPrec2_>::_source(uint i, uint j)
    {
	WorkPrec_ _h = (*_u)[(this->_d_width + 4) * i + j];
	if (_h > 0)
	{
	    WorkPrec_ _q1 = (*_u)[(this->_d_width + 4)* i + j + 1];
	    WorkPrec_ _q2 = (*_u)[(this->_d_width + 4)* i + j + 2];
	    
	    DenseVector<WorkPrec_> _result(ulint(3), ulint(0), ulint(1));
	    _result[0] = 0;
	    _result[1] = _manning_n_squared * pow(_h, -7/3) * sqrt(_q1 * _q1 + _q2 * _q2) * (-1);
	    _result[2] = _result[1];
    
	    _result[1] = ((_result[1] * _q1) - (_h * (*_bottom_slopes_x)[(this->_d_width + 4)* i + j])) * 9.81;
	    _result[2] = ((_result[2] * _q2) - (_h * (*_bottom_slopes_y)[(this->_d_width + 4)* i + j])) * 9.81;
	    return _result;
    	}
	else
	{
	    DenseVector<WorkPrec_> _result(ulint(3), ulint(0), ulint(1));
	    _result[0] = 0;
	    _result[1] = 0;
	    _result[2] = 0;
	    return _result;
	}
    }

}
#endif
