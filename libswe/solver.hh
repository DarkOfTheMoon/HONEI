/* vim: set sw=4 sts=4 et nofoldenable : */

/*
 * Copyright (c) 2007 Markus Geveler <apryde@gmx.de>
 *
 * This file is part of the SWE C++ library. LibSWE is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * LibSWE is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */


#ifndef LIBSWE_GUARD_SOLVER_HH
#define LIBSWE_GUARD_SOLVER_HH 1

/**
 * \file
 *
 * DECLARATION of a Relaxation - based, Finite Volume MUSCL in space,
 * implicit/explicit Runge Kutta in time solver. Under heavy construction.
 *
 * Solver is arbitrary in precision.
 *
 * \ingroup grplibswe
 **/
 
#include <libla/dense_matrix.hh>
#include <libla/dense_vector.hh>
#include <libla/sparse_vector.hh>
#include <libla/banded_matrix.hh>

namespace pg512 {

    typedef unsigned long ulint;
    typedef unsigned int uint;
    typedef unsigned short usint;

    template<typename ResPrec_,
             typename PredictionPrec1_,
             typename PredictionPrec2_,
             typename InitPrec1_,
             typename InitPrec2_>
    class RelaxSolver
    {
        ///Private members.
        private:
            ///Stepsize in x direction.
            ResPrec_ _delta_x;
            ///Stepsize in y direction.
            ResPrec_ _delta_y;
            ///Size of timestep.
            ResPrec_ _delta_t;
            ///Current timestep.
            ulint _solve_time;
            
            ///The input- and to-be-updated - data.
            DenseMatrix<ResPrec_> * _bottom;
            DenseMatrix<ResPrec_> * _heigth;
            DenseMatrix<ResPrec_> * _x_veloc;
            DenseMatrix<ResPrec_> * _y_veloc;

            /**
              * Performs the preprocessing.
              **/
            void _do_preprocessing();

            ///The relaxation parameter: 0<eps<<1.
            double _eps;

            ///The number of cells in the finite volume descretization grid.
            ulint _n;
            
            ///Dimension sizes for rectangular grids.
            ulint _d_width;
            ulint _d_heigth;

            ///Vector _c is the relaxation - Matrix C`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _c;

            ///Vector _d is the relaxation - Matrix D`s diagonal-vector (must be 3-dim.).
            DenseVector<ResPrec_> * _d;

            ///The corresponding "squares" of the above vectors, values generated by constructor.
            DenseVector<ResPrec_> _c_squared;
            DenseVector<ResPrec_> _d_squared;

            /** Vector under pointer contains boundary - scalars => must be (2a+2b) - dim.,
              * if a is the number of cell-steps in x-direction and b represents the same
              * in y- direction (For sqzare - grids it is 4n - dim, if n=squarroot(N), and N the total number of cells)
              * This might be useful for very complicated simulation settings. In simpler cases, one should use the
              * below options.
              **/
            DenseVector<ResPrec_> * _bottom_bound;
            DenseVector<ResPrec_> * _heigth_bound;
            DenseVector<ResPrec_> * _xveloc_bound;
            DenseVector<ResPrec_> * _yveloc_bound;

            /**
              * Boundaries: Scalars for rectangular grids. Simple version of the above vector-
              * based solution.
              *
              **/
            ResPrec_ _north_bound;
            ResPrec_ _south_bound;
            ResPrec_ _west_bound;
            ResPrec_ _east_bound;

            ///Flags for boundary usage.
            bool _simple_bound;
            bool _usage_reflect;
            bool _usage_constant;
            bool _usage_cyclic;
            bool _usage_transmissive;
        
            ///Vectors under pointers are the relaxation vectors. size is 3N, where N is the total number of grid cells.
            ///If using boundary-mapping, the size is 3N + 4(w + h + 4).
            DenseVector<ResPrec_> * _u;
            DenseVector<ResPrec_> * _v;
            DenseVector<ResPrec_> * _w;

            ///Vectors under pointers are the temp. relaxation vectors for the prediction stages.
            ///It`s size is 3N, where N is the total number of grid cells. If using boundary - mapping, the size is
            /// 3N + 4(w + h + 4).
            DenseVector<ResPrec_> * _u_temp;
            DenseVector<ResPrec_> * _v_temp;
            DenseVector<ResPrec_> * _w_temp;
            
            ///Vectors for the bottom slopes.
            DenseVector<ResPrec_> * _bottom_slopes_x; //size:w
            DenseVector<ResPrec_> * _bottom_slopes_y; //size:h

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_1, M_3.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _assemble_matrix1();

            /** Basic matrix assembling. Uses Limiters and theta().
              * Computes M_2, M_4.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _assemble_matrix2();


            /** Simplified matrix assembling.
              * Computes M_5.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix1();

            /** Simplified matrix assembling.
              * Computes M_6.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix2();

            /** Simplified matrix assembling.
              * Computes M_7.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix3();

            /** Simplified matrix assembling.
              * Computes M_8.
              *
              **/
            template<typename WorkPrec_>
            BandedMatrix<WorkPrec_> _quick_assembleMatrix4();

            /** Flow computation.
              * Used by preprocessing.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flow_x(uint i, uint j);

            /** Flow computation.
              * Used by preprocessing.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _flow_y(uint i, uint j);

            /** Flow computation.
              *
              **/
            template<typename WorkPrec_>
            void _flow_x();

            /** Flow computation.
              * 
              **/
            template<typename WorkPrec_>
            void _flow_y();


            /** Source Term computation.
              *
              * \param i Access Parameter 1.
              * \param j Access Parameter 2.
              * 
              **/
            template<typename WorkPrec_>
            DenseVector<WorkPrec_> _source(uint i, uint j);
        
            /** Encapsulates the linear combination for prediction. Uses source() 
              * as well as the matrix assembling procedures to create the banded matrices.
              * Is used by solve().
              *
              **/
            template<typename WorkPrec_>
            void _do_prediction();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow  - computations.
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage1();

            /** Encapsulates the setup for the values utemp, vtemp, wtemp.
              * Uses flow - computations.
              *
              **/
            template<typename WorkPrec_>
            void _do_setup_stage2();

             /** Encapsulates computation in one timestep. In the driver-application, one
               * can simply write a loop in which _do_solve is called at first and then the
               * renderable matrices are read out.
               *
               **/
             void _do_solve()
             {
                _do_setup_stage1<InitPrec1_>();
                _do_prediction<PredictionPrec1_>();
                _do_setup_stage2<InitPrec2_>();
                _do_prediction<PredictionPrec2_>();
                _do_correction<ResPrec_>();
                ++_solve_time;
             }

             /** Encapsulates the correction stage.
              *  Precision is that of the result.
              **/
             template<typename WorkPrec_> 
             void _do_correction();

        public:
            /**
              * Returns the current renderable heigth matrix
              * 
              **/
            DenseMatrix<ResPrec_> &getHeigth();

            /**
              * Returns the renderable bottom.
              *
              **/
            DenseMatrix<ResPrec_> &getBottom();

            ///Constructors
            /**
             * First simple public constructor for tests.
             *
             * \param heigth The input heigth -field.
             * \param bottom The input bottom -field.
             * \param u1 The x -velocity field.
             * \param u2 The y -velocity field.
             * \param u The relaxation vector u.
             * \param v The relaxation vector v.
             * \param w The relaxation vector w.
             * \param dwidth The width of the FV - discretization grid.
             * \param dheigth The heigth of the FV - discretization grid.
             * \param deltax The x - stepsize.
             * \param deltay The y - stepsize.
             * \param deltat The time - stepsize.
             * \param eps The relaxation parameter.
             **/
            RelaxSolver(DenseVector<ResPrec_> *heigth,
                        DenseVector<ResPrec_> *bottom,
                        DenseVector<ResPrec_> *u1,
                        DenseVector<ResPrec_> *u2,
                        DenseVector<Resprec_> *u,
                        DenseVector<ResPrec_> *v,
                        DenseVector<ResPrec_> *w,
                        ResPrec_ dwidth,
                        ResPrec_ dheigth,
                        ResPrec_ deltax,
                        ResPrec_ deltay,
                        ResPrec_ deltat
                        double eps)
            {
                this->_heigth = heigth;
                this->_bottom = bottom;
                this->_u1 = u1;
                this->_u2 = u2;
                this->_u = u;
                this->_v = v;
                this->_w = w;
                this->_d_width = dwidth;
                this->_d_heigth = dheigth;
                this->_delta_x = deltax;
                this->_delta_y = deltay;
                this->_delta_t = deltat;
                this->_eps = eps;

                this->_simple_bound = true;
                this->_usage_reflect = true;
                this->_usage_constant = false;
                this->_usage_cyclic = false;
                this->_usage_transmissive = false;

                this->_n = _width * _heigth;

                DenseVector<ResPrec_> c(3,0,1);
                DenseVector<ResPrec_> d(3,0,1);
                c[0] =1; d[0] = c[0]*c[0];
                c[1] =2; d[1] = c[1]*c[1];
                c[2] =3; d[2] = c[2]*c[2];

            }

    };

    ///MEMBER FUNCTION TEMPLATE IMPLEMENTATION

    /**
     *
     * Implementation of the preprocessing stage of the RelaxSolver.
     *
     * At first, the input scalarfields have to be mapped onto a larger
     * DenseMatrix in order to apply boundary conditions.
     *
     * Secondly, the h,u1 und u2 - values have the
     * locations in the relaxation vectors.
     *
     * The preprocessing stage`s third task is to compute the bottom slopes.
     *
     **/
    template<typename ResPrec_, 
             typename PredictionPrec1_,
             typename PredictionPrec2_,
             typename InitPrec1_,
             typename InitPrec2_>
    void RelaxSolver<ResPrec_, PredictionPrec1_, PredictionPrec2_, InitPrec1_, InitPrec2_>::_do_preprocessing()
    {
        /// Setting up initial conditions:
        /// v_0(x,y) = F(u_0(x,y)) using flowX(),
        /// w_0(x,y) = G(u_0(x,y)) using flowY().
        /// where u = transpose((h q1 q2)), v = transpose((v1 v2 v3)) and w = transpose((w1 w2 w3))
        /// and q1 = h*u1, q2 = h*u2.
        /// Then apply boundary conditions.
    
        ///Provide maps.
        DenseMatrix<ResPrec_> hbound((this->_width)+4,  (this->_heigth)+4, 0);
        DenseMatrix<ResPrec_> u1bound((this->_width)+4, (this->_heigth)+4, 0);
        DenseMatrix<ResPrec_> u2bound((this->_width)+4, (this->_heigth)+4, 0);
        DenseMatrix<ResPrec_> bbound((this->_width)+4,  (this->_heigth)+4, 0);


        ///Do the mapping by applying boundary - usage.
        if(this->_reflect && this->_simple_bound)
        {
            ///If assuming, that all input fields are exactly of the same size, we can do all the work within
            ///one loop - pair:
            for (unsigned long i = 0; i!= hbound.rows(); ++i) 
            {
                DenseVector<ResPrec_> actual_row = hbound[i];
                for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                                     j_END(actual_row.end_elements());
                                                                     j!= j_END; ++j)
                {
                    ///Check if boundary - ghost cell is going to be accessed.
                    if(i<2 || i>=(hbound.rows()-2) ||(j<2 || j>=(hbound.columns()-2)))
                    {
                        hbound[i][j.index()] = 0;
                        bbound[i][j.index()] = 100000; //TODO: PosInf
                        u1bound[i][j.index()] = 0;
                        u2bound[i][j.index()] = 0;
                    }
                    else
                    {
                        hbound[i][j.index()] = this->*(_heigth)[i-2][(j.index())-2];
                        bbound[i][j.index()] = this->*(_bottom)[i-2][(j.index())-2];
                        u1bound[i][j.index()] = this->*(_x_veloc)[i-2][(j.index())-2];
                        u2bound[i][j.index()] = this->*(_y_veloc)[i-2][(j.index())-2];
                    }
                }
            }
        }//TODO: the other cases of boundary usage

        ///Building up the relaxation - vectors by concatenating the maps` rows.
        ///We need to compute u first in order to be able to compute the initial flows. After this, by using
        ///forward iterators, the v and w vectors can be set up.
        for (ulint i= 0; i!= hbound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = hbound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k(this->*(_u).begin_elements());
                                                                j!= j_END; ++j)
            {
                this->*(_u)[k.index()] = hbound[i][j];
                this->*(_u)[(k.index())+1] = u1bound[i][j.index()] * hbound[i][j.index()];
                this->*(_u)[(k.index())+2] = u2bound[i][j.index()] * hbound[i][j.index()];
                k +=3;
            }
    
        }

        for (ulint i = 0; i!= u1bound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = u1bound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k(this->*(_v).begin_elements());
                                                                j!= j_END; ++j)
            {
                DenseVector<ResPrec_> flow(3,0,1);
                flow = this->_flow_x<ResPrec_>(i,j.index());

                this->*(_v)[k.index()] = flow[0];
                this->*(_v)[(k.index())+1] = flow[1];
                this->*(_v)[(k.index())+2] = flow[2];
                k +=3;
            }
        }
    
        for (ulint i = 0; i!= u2bound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = u2bound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k(this->*(_w).begin_elements());
                                                                j!= j_END; ++j)
            {
                DenseVector<ResPrec_> flow(3,0,1);
                flow = this->_flow_y<ResPrec_>(i,j.index());

                this->*(_w)[k.index()] = flow[0];
                this->*(_w)[(k.index())+1] = flow[1];
                this->*(_w)[(k.index())+2] = flow[2];
                k +=3;
            }
        }
    
        ///Now, that the relaxation vectors have been provided, the only thing left to do is to 
        ///compute the bottom slopes.
        for (ulint i = 0; i!= bbound.rows(); ++i) 
        {
            DenseVector<ResPrec_> actual_row = bbound[i];
            for(typename DenseVector<ResPrec_>::ElementIterator j(actual_row.begin_elements()),
                                                            j_END(actual_row.end_elements()),
                                                            k(this->*(_bottom_slopes_x).begin_elements()),
                                                            l(this->*(_bottom_slopes_y).begin_elements());
                                                                j!= j_END; ++j)
            {
                if(i>0 && j>0)
                {
                    this->*(_bottom_slopes_x)[k.index()] = (bbound[i][j.index()] - bbound[i-1][j.index()]) /this->_delta_x;  
                    this->*(_bottom_slopes_y)[l.index()] = (bbound[i][j.index()] - bbound[i][(j.index())-1]) /this->_delta_y;                
 
                }
                else
                {
                    this->*(_bottom_slopes_x)[k.index()] = -100000; 
                    this->*(_bottom_slopes_y)[l.index()] = -100000;               
 
                }
                ++k;
                ++l;
            }   
        }
    

    }   

}
#endif
